// A simple trend-following strategy using moving averages
// and strong price action to generate entry signals.
// Best for trending markets.
// Â© timoanttila

//@version=6
indicator("Trend is your best friend [timoanttila]", shorttitle="Trend", overlay=true)

// ----------
//  SETTINGS
// ----------

group1 = "Moving Averages"
ma1_length = input.int(10, title="Cross1 MA Length", maxval=50, minval=9, group=group1)
ma1_type = input.string("EMA", title="Cross1 MA Type", options=["SMA", "EMA"], group=group1)

ma2_length = input.int(48, title="Cross2 MA Length", maxval=50, minval=9, group=group1)
ma2_type = input.string("EMA", title="Cross2 MA Type", options=["SMA", "EMA"], group=group1)

ma3_length = input.int(200, title="Long MA Length", maxval=200, minval=50, group=group1)
ma3_type = input.string("SMA", title="Long MA Type", options=["SMA", "EMA"], group=group1)

group2 = "Risk Management"
only_longs = input.bool(false, title="Only Longs trades", group=group2)
n_bars_wait = input.int(15, "Number of bars to wait after breakout", maxval=50, minval=5, step=1, group=group2)
n_bars = input.int(defval=4, title="Number of clearing bars", minval=1, maxval=20, group=group2)
min_body_perc = input.float(40, "Min entry candle body %", minval=20, maxval=95, group=group2)

line_and_text_color = color.new(color.white, 50)
pd_active = timeframe.in_seconds() <= 14400
pd_active_signal = timeframe.in_seconds() <= 300

// ----------
//  MOVING AVERAGES
// ----------

calculate_ma(ma_type, src, length) =>
    ma_type == "SMA" ? ta.sma(src, length) : ta.ema(src, length)

// Calculate the moving averages
ma1 = calculate_ma(ma1_type, close, ma1_length)
ma2 = calculate_ma(ma2_type, close, ma2_length)
ma3 = calculate_ma(ma3_type, close, ma3_length)

plot(ma1, color=color.yellow, linewidth=1, title="Cross MA1")
plot(ma2, color=color.orange, linewidth=1, title="Cross MA2")
plot(ma3, color=color.white, linewidth=2, title="Long MA")

// ----------
//  GLOBAL VARIABLES
// ----------

int ma_entry = 0 // 0 = no go, 1 = bull, 2 = bear
int ma_entry_more = 0
int ma_exit = 0
int pd_entry = 0
var bool ma_color_change = false
var bool ma_entry_taken = false
var bool pd_breakout = false
var bool pd_entry_taken = false
var float entry_clear = 0
var float ma_pullback = 0
var float pd_pullback = 0
var int trend = 0
var int wait_index = 0
var label text_high = na
var label text_low = na
var label text_mid = na
var label text_open = na
var line line_high = na
var line line_low = na
var line line_mid = na
var line line_open = na

// ----------
//  DAILY LEVELS
// ----------

new_day = dayofmonth != dayofmonth[1]
[dh, dl, d_open] = request.security(syminfo.tickerid, "D", [high[1], low[1], open], lookahead=barmerge.lookahead_on)
mid = (dh + dl) / 2

pd_inside = (low > dl) and (high < dh)

if pd_active and new_day
    pd_breakout := false
    pd_entry_taken := false
    pd_pullback := 0

    if not na(line_high)
        line.delete(line_high), label.delete(text_high)
    if not na(line_low)
        line.delete(line_low), label.delete(text_low)
    if not na(line_mid)
        line.delete(line_mid), label.delete(text_mid)
    if not na(line_open)
        line.delete(line_open), label.delete(text_open)

    end_bar = bar_index + 5
    transparent = color.new(line_and_text_color, 100)

    line_high := line.new(bar_index, dh, end_bar, dh, color=line_and_text_color)
    line_low := line.new(bar_index, dl, end_bar, dl, color=line_and_text_color)
    line_mid := line.new(bar_index, mid, end_bar, mid, color=color.new(color.orange, 50), style=line.style_dashed)
    line_open := line.new(bar_index, d_open, end_bar, d_open, color=color.new(color.teal, 50))

    text_high := label.new(end_bar, dh, "PDH", style=label.style_label_left, textcolor=line_and_text_color, size=size.small, color=transparent)
    text_low := label.new(end_bar, dl, "PDL", style=label.style_label_left, textcolor=line_and_text_color, size=size.small, color=transparent)
    text_mid := label.new(end_bar, mid, "50%", style=label.style_label_left, textcolor=color.orange, size=size.small, color=transparent)
    text_open := label.new(end_bar, d_open, "DO", style=label.style_label_left, textcolor=color.teal, size=size.small, color=transparent)

if pd_active
    end_bar = bar_index + 5
    if not na(line_high)
        line.set_x2(line_high, end_bar), label.set_x(text_high, end_bar)
    if not na(line_low)
        line.set_x2(line_low, end_bar), label.set_x(text_low, end_bar)
    if not na(line_mid)
        line.set_x2(line_mid, end_bar), label.set_x(text_mid, end_bar)
    if not na(line_open)
        line.set_x2(line_open, end_bar), label.set_x(text_open, end_bar)

// ----------
//  CANDLE VALIDATION
// ----------

is_bear = close < open
is_bull = close > open

candle_body = math.abs(close - open)
candle_full_size = math.abs(high - low)
prev_candle_body = math.abs(close[1] - open[1])
prev_highest = ta.highest(high, n_bars)[1]
prev_lowest = ta.lowest(low, n_bars)[1]

candle_body_ok = (candle_body / candle_full_size) * 100 > min_body_perc
candle_trend = trend == 1 ? is_bull and close > prev_highest and close > ma1 and open > ma2 : is_bear and close < prev_lowest and close < ma1 and open < ma2
candle_valid = candle_trend and candle_body_ok

// ----------
//  MOVING AVERAGE CROSSOVER
// ----------

bool cross_bear = ta.crossunder(ma1, ma2)
bool cross_bull = ta.crossover(ma1, ma2)
bool cross_exit_bear = ta.crossover(close, ma2)
bool cross_exit_bull = ta.crossunder(close, ma2)
bool entry_cross = cross_bull or cross_bear
bool exit_cross = cross_exit_bull or cross_exit_bear

if entry_cross or exit_cross
    if ma_entry_taken and exit_cross
        ma_exit := trend

    entry_clear := 0
    ma_color_change := false
    ma_entry_taken := false
    ma_pullback := 0

    if not pd_breakout
        wait_index := 0

    if entry_cross
        trend := cross_bull ? 1 : 2

bool pd_in_bear = ta.crossunder(close, dh)
bool pd_in_bull = ta.crossover(close, dl)
bool pd_out_bear = ta.crossunder(close, dl)
bool pd_out_bull = ta.crossover(close, dh)

if not pd_active_signal
    if pd_out_bear or pd_out_bull
        pd_breakout := true
        wait_index := 0

    else if not pd_entry_taken and pd_in_bear or pd_in_bull
        pd_breakout := false
        wait_index := 0

// ----------
//  ENTRY LOGIC
// ----------

if (not only_longs or trend == 1)
    if not ma_entry_taken
        if candle_valid and candle_body > (prev_candle_body * 1.2)
            entry_clear := trend == 1 ? high : low
            ma_entry := trend
            ma_entry_taken := true
            ma_exit := 0

        else
            wait_index := wait_index + 1

    else if not ma_color_change and ma_exit == 0
        if ma_pullback > 0
            if candle_valid and ((trend == 1 and close > ma_pullback) or (trend == 2 and close < ma_pullback))
                entry_clear := trend == 1 ? low : high
                ma_color_change := true
                ma_entry_more := trend

        else if trend == 1 and is_bear and high > entry_clear
            ma_pullback := high

        else if trend == 2 and is_bull and low < entry_clear
            ma_pullback := low

    if pd_active_signal and pd_active and not pd_entry_taken
        is_above_pd = close > dh
        is_below_pd = close < dl

        if pd_pullback > 0 and candle_body_ok and ((is_above_pd and close > pd_pullback) or (is_below_pd and close < pd_pullback))
            ma_entry_taken := true
            ma_exit := 0
            pd_breakout := false
            pd_entry := is_above_pd ? 1 : 2
            pd_entry_taken := true

        else
            if is_above_pd and is_bear and (pd_pullback == 0 or close < pd_pullback)
                pd_pullback := high

            else if is_below_pd and is_bull and (pd_pullback == 0 or close > pd_pullback)
                pd_pullback := low

// ----------
//  ENTRY MARKERS
// ----------

loc_bear = location.abovebar
loc_bull = location.belowbar
plot_size = size.tiny

color_entry = color.new(color.white, 20)
plotshape(ma_entry == 1, style=shape.triangleup, location=loc_bull, color=color_entry, size=plot_size, title="Bullish Entry")
plotshape(ma_entry == 2, style=shape.triangledown, location=loc_bear, color=color_entry, size=plot_size, title="Bearish Entry")

// Additional MA entry
signal_shape = shape.cross
plotshape(ma_entry_more == 1, style=signal_shape, location=loc_bull, color=color_entry, size=plot_size, title="Bullish Entry")
plotshape(ma_entry_more == 2, style=signal_shape, location=loc_bear, color=color_entry, size=plot_size, title="Bearish Entry")

// Exit from MA entry
color_exit = color.new(color.gray, 20)
signal_shape := shape.xcross
plotshape(ma_exit == 1, style=signal_shape, location=loc_bull, color=color_exit, size=plot_size, title="Bullish Entry")
plotshape(ma_exit == 2, style=signal_shape, location=loc_bear, color=color_exit, size=plot_size, title="Bearish Entry")

// Previous Day Breakout
signal_shape := shape.diamond
plotshape(pd_entry == 1, style=signal_shape, location=loc_bull, color=color_entry, size=plot_size, title="Bullish Entry")
plotshape(pd_entry == 2, style=signal_shape, location=loc_bear, color=color_entry, size=plot_size, title="Bearish Entry")

// ----------
//  ALERTS
// ----------

alertcondition(ma_entry > 0, title="MA Entry", message="New signal based on moving averages")
alertcondition(ma_entry > 0 or ma_entry_more > 0, title="MA Entry or Add", message="New signal based on moving averages")
alertcondition(ma_entry == 1, title="MA Long Entry", message="New long signal based on moving averages")
alertcondition(ma_entry == 2, title="MA Short Entry", message="New short signal based on moving averages")
alertcondition(pd_entry > 0, title="PD Break Entry", message="Asset broke out of the previous day's range")
alertcondition(ma_entry > 0 or pd_entry > 0, title="MA or PD Entry", message="New signal based on moving averages or previous day range")
alertcondition(ma_entry > 0 or ma_entry_more > 0 or pd_entry > 0, title="MA, PD or Add Entry", message="New signal based on moving averages, previous day range")
alertcondition(ma_exit > 0, title="Exit", message="Now would be good time to think about profits")