// A simple trend-following strategy using moving average
// and fair value gaps to generate entries.
// Best for trending markets.
// Â© timoanttila

//@version=6
indicator("Fair Value Gaps - Trend is your best friend [timoanttila]", shorttitle="FVG", overlay=true, dynamic_requests=true)

// ----------
//  SETTINGS
// ----------

group1 = "Moving Averages"
base_length = input.int(20, title="Base MA Length", maxval=50, minval=9, group=group1)
base_type = input.string("SMA", title="Base MA Type", options=["SMA", "EMA"], group=group1)
long_length = input.int(200, title="Long MA Length", maxval=200, minval=50, group=group1)
long_type = input.string("SMA", title="Long MA Type", options=["SMA", "EMA"], group=group1)

calculate_ma(ma_type, src, length) =>
    ma_type == "SMA" ? ta.sma(src, length) : ta.ema(src, length)

// Calculate the moving averages
ma_base = calculate_ma(base_type, close, base_length)
ma_long = calculate_ma(long_type, close, long_length)

plot(ma_base, color=color.yellow, linewidth=2, title="Base MA")
plot(ma_long, color=color.orange, linewidth=2, title="Long MA")

// ----------
//  VWAP
// ----------

group2 = "Volume Weighted Average Price"
vwap_anchor = input.string("Weekly", title="VWAP Anchor", options=["Session", "Weekly"], group=group2)
use_vwap = input.bool(false, title="Use VWAP instead of the long MA for crossovers", group=group2)
vwap_value = vwap_anchor == "Session" ? ta.vwap(hlc3) : ta.vwap(hlc3, timeframe.change("1W"))
plot(vwap_value, "VWAP", color=color.aqua, linewidth=3)

// ----------
//  RISK MANAGEMENT
// ----------

group3 = "Risk Management"
only_longs = input.bool(false, title="Only Longs trades", group=group3)
base_reset = input.bool(true, title="Values are reseted when price crosses the base MA", group=group3)
n_bars = input.int(6, "Number of clearing bars", minval=1, group=group3)
n_bars_wait = input.int(10, "Number of bars to wait after breakout", maxval=50, minval=5, step=1, group=group3)
min_body_perc = input.float(40, "Min entry candle body %", minval=20, maxval=95, step=1, group=group3)
fvg_min_size = input.float(30, "Min FVG size (% of ATR)", maxval=60, minval=10, step=1, group=group3)

// ----------
//  GLOBAL VARIABLES
// ----------

bool is_bear = close < open
bool is_bull = close > open
float atr = ta.atr(14)
float prev_highest = ta.highest(high, n_bars)[1]
float prev_lowest = ta.lowest(low, n_bars)[1]
int entry = 0
int entry_more = 0
var bool color_change = false
var bool entry_taken = false
var bool first_fvg_found = false
var box[] bear_fvg_boxes = array.new<box>()
var box[] bull_fvg_boxes = array.new<box>()
var float entry_clear = 0
var float pullback_value = 0
var int entry_count = 0
var int short_trend = 0
var int trend = 0

// ----------
//  BIAS
// ----------

main_long = use_vwap ? vwap_value : ma_long
bool cross_bear = ta.crossunder(close, main_long)
bool cross_bull = ta.crossover(close, main_long)
bool trend_cross = cross_bear or cross_bull

bool base_bear = ta.crossunder(close, ma_base)
bool base_bull = ta.crossover(close, ma_base)
bool reset_cross = base_reset and ((trend == 1 and base_bear) or (trend == 2 and base_bull))

if trend_cross or reset_cross
    color_change := false
    entry_count := 0
    entry_taken := false
    first_fvg_found := false
    pullback_value := 0

    if trend_cross
        entry_clear := 0
        short_trend := cross_bull ? 1 : 2

// Daily Bias Calculation
daily_open = request.security(syminfo.tickerid, "D", open, lookahead=barmerge.lookahead_on)
daily_bias = daily_open < close ? 1 : 2
bool strong_trend = daily_bias == short_trend

if strong_trend
    trend := daily_bias
else
    trend := 0

bgcolor(daily_bias == 1 ? color.new(color.green, 75) : color.new(color.red, 75))

// ----------
//  FAIR VALUE GAP DETECTION
// ----------

fvg_min_size := fvg_min_size / 100

// Bullish FVG: Current low > high from 2 bars ago
bullish_fvg = low > high[2] and high > high[1]
bull_fvg_size = bullish_fvg ? low - high[2] : 0
bull_fvg_valid = bullish_fvg and bull_fvg_size > (atr * fvg_min_size)

// Bearish FVG: Current high < low from 2 bars ago
bearish_fvg = high < low[2] and low < low[1]
bear_fvg_size = bearish_fvg ? low[2] - high : 0
bear_fvg_valid = bearish_fvg and bear_fvg_size > (atr * fvg_min_size)

// Create and store FVG boxes
if bull_fvg_valid
    new_box = box.new(left=bar_index - 1, top=low, right=bar_index + 4, bottom=high[2], bgcolor=color.new(color.green, 85), border_color=color.new(color.green, 50), border_width=1)
    array.push(bull_fvg_boxes, new_box)

else if bear_fvg_valid
    new_box = box.new(left=bar_index - 1, top=low[2], right=bar_index + 4, bottom=high, bgcolor=color.new(color.red, 85), border_color=color.new(color.red, 50), border_width=1)
    array.push(bear_fvg_boxes, new_box)

// ----------
//  ENTRY LOGIC
// ----------

if trend > 0 and n_bars_wait > entry_count and (not only_longs or (only_longs and trend == 1))
    // Track first FVG after trend reset
    if not first_fvg_found and ((trend == 1 and bull_fvg_valid) or (trend == 2 and bear_fvg_valid))
        first_fvg_found := true

    // Candle validation
    float candle_body = math.abs(close - open)
    float candle_full_size = math.abs(high - low)
    float prev_candle_body = math.abs(close[1] - open[1])
    bool candle_body_percent = (candle_body / candle_full_size) * 100 > min_body_perc
    bool candle_trend = trend == 1 ? is_bull and close > prev_highest : is_bear and close < prev_lowest
    bool candle_valid = candle_trend and candle_body_percent and volume > volume[1]

    if not entry_taken
        if first_fvg_found and candle_valid
            entry := trend
            entry_clear := trend == 1 ? high : low
            entry_taken := true

        else if (trend == 1 and is_bull and high > ma_base) or (trend == 2 and is_bear and low < ma_base)
            entry_count := entry_count + 1

    else if not color_change and entry_clear > 0
        if pullback_value > 0 and candle_valid and ((trend == 1 and close > pullback_value) or (trend == 1 and close > pullback_value))
            entry_more := trend
            color_change := true

        else if pullback_value == 0 and ((trend == 1 and is_bear and close > entry_clear) or (trend == 2 and is_bull and close < entry_clear))
            pullback_value := trend == 1 ? high : low

// ----------
//  VISUAL SIGNALS
// ----------

entry_color = color.new(color.white, 20)
plotshape(entry == 1, title="Bull Entry", style=shape.triangleup, location=location.belowbar, color=entry_color, size=size.tiny)
plotshape(entry == 2, title="Bear Entry", style=shape.triangledown, location=location.abovebar, color=entry_color, size=size.tiny)

plotshape(entry_more == 1, title="Long Add", style=shape.cross, location=location.belowbar, color=entry_color, size=size.tiny)
plotshape(entry_more == 2, title="Short Add", style=shape.cross, location=location.abovebar, color=entry_color, size=size.tiny)

// ----------
//  ALERTS
// ----------

alertcondition(entry > 0, title="New Entry", message="New entry signal detected")
alertcondition(entry == 1, title="New Bullish Entry", message="New entry signal detected")
alertcondition(entry == 2, title="New Bearish Entry", message="New entry signal detected")

// ----------
//  BOX CLEANUP
// ----------

if barstate.isconfirmed
    // Bearish FVG cleanup (reverse)
    int i = array.size(bear_fvg_boxes) - 1
    while i >= 0
        b = array.get(bear_fvg_boxes, i)
        top = box.get_top(b)
        if close > top or high > top
            box.delete(b)
            array.remove(bear_fvg_boxes, i)
        i := i - 1

    // Bullish FVG cleanup (reverse)
    int j = array.size(bull_fvg_boxes) - 1
    while j >= 0
        bb = array.get(bull_fvg_boxes, j)
        bot = box.get_bottom(bb)
        if close < bot or low < bot
            box.delete(bb)
            array.remove(bull_fvg_boxes, j)
        j := j - 1